---
created: 2023-07-06 13:00
updated: 2023-07-06 15:13
---
---
**Links**: [[111 KodeCloud Index]]

---
## Prometheus
- Simple architecture diagram:
	- ![[attachments/Pasted image 20230706130646.png]]
- **The things that prometheus monitors are known as targets**.
	- Some common targets are *linux servers*, *databases*, *containers*, etc.
- *Each target has units of monitoring*.
	- Like CPU status, requests count, disk usage etc.
- **The unit we monitor for a specific target is known as a metric**.
- *Metrics are saved in the prometheus database component*.
- *Metrics are in a human readable format*.
- Example of a metric:

```
# HELP http_requests_total Total number of http api requests
# TYPE http_requests_total counter
http_requests_total{api="add_product"} 4633433
```

- `# HELP` is used to provide a description for the metric and `# TYPE` a type for the metric.

> [!question]+ How prometheus works?
> - Prometheus primarily *utilizes an HTTP endpoint to scrape metric data from instrumented services and applications*. 
> - The Prometheus server is in charge of *periodically scraping the targets* so that applications and *services don’t need to worry about emitting data* (**metrics are pulled**, NOT pushed)
> - These endpoints present their respective metrics in plaintext HTTP format — the metrics are either scraped by the Prometheus server directly or extracted through a push gateway for short-lived, instrumented jobs.
> - These *scraped metrics are stored locally as aggregated time-series data* for capturing events and historical representation. 
> - Prometheus *exposes these aggregated metrics further through an API* for consuming services, such as Grafana, for real-time and historical visualization of metric data.

### Key components of prometheus
- Complex architecture diagram:
	- ![[attachments/Pasted image 20230706132654.png]]
- **Prometheus server**: The Prometheus server represents the standalone machine instance that schedules the querying of metric endpoints at a predefined sampling frequency along with the scraping and storing of metrics data. 
- *Client libraries*: Client libraries enable developers to add Prometheus instrumentation to their code; this instrumentation helps define and expose application metrics for each application language. 
- **Pushgateway**: In *systems that are NOT compatible with pull-based metric* scraping, Prometheus provides an additional Pushgateway component for gathering metrics from external services and applications. 
	- Pushgateway is particularly useful for ephemeral, short-lived jobs that may initiate and terminate before the Prometheus server can identify and scrape metrics from them.
- **Exporters**: Exporters are a collection of components, servers, and libraries that *enable Prometheus to scrape metrics from third-party systems when the target endpoint or service can’t expose them directly in Prometheus’s required format*.
	- One example is, the *Prometheus node exporter*. It exposes all Linux system-level metrics in Prometheus format.
- **Alertmanager**: The Prometheus Alertmanager orchestrates alerts generated by the Prometheus server when a user-defined rule meets an alert condition. 
	- The Alertmanager can be configured to send notifications via in-built notification receivers such as Slack, OpsGenie, and PagerDuty, or via email notifications.

### Different types of metrics
#### Counters
- Counter metrics are used for *measurements that only increase*. 
- Therefore they are always cumulative—their value can **only go up**.

```
# HELP http_requests_total Total number of http api requests
# TYPE http_requests_total counter
http_requests_total{api="add_product"} 4633433
```

- The metric name is `http_requests_total`, it has one label named `api` with a value of `add_product` and the counter’s value is `4633433`. 
- This means that the `add_product` API has been called 4,633,433 times since the last service start or counter reset. 
	- By convention, counter metrics are usually suffixed with `_total`.
- *The absolute number does not give us much information, but when used with PromQL’s `rate` function* (or a similar function in another monitoring backend), it helps us understand the requests per second that API is receiving. 
	- The PromQL query below calculates the average requests per second over the last five minutes:

```
rate(http_requests_total{api="add_product"}[5m])
```

#### Gauges
- Gauge metrics are used for measurements **that can arbitrarily increase or decrease**. 
- This is the metric type we are likely more familiar with since the actual value with no additional processing is meaningful and they are often used. 
	- For example, metrics to measure *temperature, CPU, and memory usage*, or the size of a queue are gauges.

```
# HELP node_memory_used_bytes Total memory used in the node in bytes
# TYPE node_memory_used_bytes gauge
node_memory_used_bytes{hostname="host1.domain.com"} 943348382
```

- The metric above indicates that the memory used in node `host1.domain.com` at the time of the measurement is around 900 megabytes. 
	- *The value of the metric is meaningful without any additional calculation because it tells us how much memory is being consumed on that node*.
- Unlike when using counters, `rate` and `delta` functions don’t make sense with gauges. 
- However, *functions that compute the maximum, minimum, or average for a specific series are often used with gauges*. 
	- In Prometheus, the names of those functions are `max_over_time`, `min_over_time`, and `avg_over_time`.

```
avg_over_time(node_memory_used_bytes{hostname="host1.domain.com"}[10m])
```

#### Histograms
- Histogram metrics are useful to represent a **distribution of measurements**. 
	- They are often used to measure *request duration or response size*.
- This metric is *ideal for data aggregation*.

#### Summaries
- Like histograms, *summary metrics are useful to measure request duration and response sizes*.

### Prometheus in k8s
- *Things that are generally installed/used with prometheus to form the monitoring stack on k8s*:
	- **Alert manager**
	- **Grafana**
	- **Node Exporter**: 
		- For *linux related metrics*.
		- It is *run as a daemon set*.
	- **Kube state metrics**
		- This *needs to be installed*.
	- *Control-Plane Components* (api-server, coredns, kube-scheduler)
	- *Kubelet* (cAdvisor) - exposing container metrics
- Simple diagram showing how prometheus, grafana and alert manager interact with each other.
	- ![[attachments/Pasted image 20230706141922.png]]

> [!note]- Best way to deploy Prometheus is using Helm chart to deploy Prometheus operator
> - `helm repo add prometheus-community https://prometheus-community.github.io/helm-charts`
> - `helm repo update`
> - `helm install [RELEASE-NAME] prometheus-community/kube-prometheus-stack`

- *Service discovery in k8s* allows prometheus to **automatically detect targets**.

## References
- [A Deep Dive Into the Four Types of Prometheus Metrics (timescale.com)](https://www.timescale.com/blog/four-types-prometheus-metrics-to-collect/)
- [Kubernetes Monitoring Made Easy with Prometheus | KodeKloud - YouTube](https://www.youtube.com/watch?v=6xmWr7p5TE0)
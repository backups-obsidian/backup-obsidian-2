---
created: 2024-01-13 16:45
updated: 2024-02-26 19:27
---
---
**Links**: [[../100 home|100 home]]

---

[[System Design - CAP Theorem]]

- **DONT JUMP INTO THE SOLUTION WITHOUT ASKING QUESTIONS**.
- When presented with an *ambiguous system design question* first ask what are the **functional requirements (system behaviour)**.
	- For example if the interviewer asks you to design YouTube then ask what feature (search, recommendation, liking, upload, watch etc) should be designed.
	- Or you can come up with your assumptions for what the application should be able to do.
- Some **non functional requirements** to think about is 
	- *Reliability*
	- *Scale*
	- *Availability*
	- *Latency*
	- *Security*
	- *Durability*
- **Estimate the data you are dealing with by doing some math**. This is also known as capacity estimation.
	- For example if you are building a storage service and the application will have a million uploads a day and each upload is about 5 MB then the application needs to process 5 Million megabytes per day.
	- *If not provided then make some assumptions and check with the interviewer*.
- Think if the system is **read heavy or write heavy**. *Generally systems are always more read heavy than they are write heavy*.
	- In case of a read heavy system add read replicas.
	- If we want to make database reads faster then we can add an in memory cache (redis).
	- It is not possible to cache everything but cache things (maybe about 20% depending on the math) that would be requested the most. For example for an URL shortener it makes sense to cache the URLs of celebrities since they will be requested most often.
- **Define the APIs for the functional requirements like the name and the parameters they will take and what will be the response**.
	- Try to include versioning in the name like v1.
- **If we want higher consistency then we will higher latency**.
- There are roughly **100,000s in a day**.
- **Think about using CDNs for caching and reducing user latency**.
- *Billion bytes is 1 GB*.
- SQL databases are harder to scale as compared to NoSQL databases. *When you are dealing with a lot of data try to go with NoSQL databases for simplicity*.

> [!note] Have justification for everything you write or draw.

- Always start with a very simple design and then think about scalability later.
- *Identify single point of failures in the system* and discuss what can be done to fix it.
	- Replication can help.
- Depending on the requirement we will have to *choose between availability and consistency (CAP theorem)*.
- Use load balancer for scaling and reliability.
- After making assumptions always ask the interviewer is there anything that I have left?
- Use object storage like S3 for storing large files.
- Use queues for asynchronous processing.
- Use CDNs for reducing user latency.
- Choose between TCP or UDP depending on the requirements.
- Apply rate limits to APIs.
- Accept that you don't know something.
- Continuously ask if you are going in the right direction.
- Retries with exponential backoff. 
	- With jitter if the interviewer brings it.
- Retry with idempotent APIs.
	- Using idempotent keys generated by the client for that transaction and sent to the payment gateway as in the request header.
- Use webhooks when you don't want to use polling.
	- A webhook is a URL that a client provides to a server which is then called by the server when a specific event occurs and the client needs to be notified about it.
	- It is a POST request with payload information about the event.
- *Using webhooks is a great example of event driven design*.
- If you are asked to design a rate limiting algorithm then go with token bucket algorithm.
	- In token bucket algorithm a token is added at a fixed rate to a bucket and each request consumes a token. For example if we add 0.5 tokens per second then at max we can make 30 requests per minute.
	- There is no need of thread to constantly fill the bucket. We can fill it using the time difference between the last call and the current call multiplied by the rate.
		- ![[attachments/Pasted image 20240221173113.png]]
- ACID stands for Atomicity, Consistency, Isolation, and Durability.
	- *Atomicity*: This ensures that a transaction is treated as a single, indivisible unit. Either all the operations within the transaction are completed successfully, or none of them are. 
		- Imagine transferring money between accounts: either both accounts are updated, or neither is. Atomicity prevents partial updates that could leave the data in an inconsistent state.
	- *Consistency*: This guarantees that the database moves from one valid state to another after each transaction. Transactions must adhere to defined business rules and constraints to maintain data integrity. For example, a product's quantity cannot be negative after a purchase transaction. 
	- *Isolation*: This property ensures that concurrent transactions don't interfere with each other. Each transaction appears to execute independently, even if multiple transactions run at the same time.
	- *Durability*: This guarantees that once a transaction is committed (finalized), its changes are persisted permanently to the database and survive even system failures.
- If you are building a chat server then use web sockets for 2 way (both server and client can send requests to each other - full duplex) communication.
	- In web sockets the connection remains open during the duration of the session so at max a server can handle 65535 connections. So depending upon the users and number of open connections we might need a lot of servers.
	- It is difficult to scale web sockets since they are stateful.
- When data is stored in object storage like S3 use pre-signed URLs to download data instead of streaming data from the API servers.
	- The API servers will return the pre-signed URL and the client will fetch the image from there.
	- For upload use the the api servers since some changes to database might be needed after the upload.

### Choosing between SQL and NoSQL
|                                SQL                                |                                  NoSQL                                   |
|:-----------------------------------------------------------------:|:------------------------------------------------------------------------:|
| Data has well defined schema and is unlikely to change frequently | There is no fixed schema and the data is unstructured or semi structured |
|                  ACID transactions are necessary                  |                       Cannot get ACID transactions                       |
|      It is difficult to scale and will have to use sharding       | Designed to scale horizontally (have built in replication and sharding)  |
|                        Strongly consistent                        |                          Eventually consistent                           |

- In SQL databases we can easily do complex queries.

## References
- https://www.youtube.com/watch?v=zgIyzEEXfiA
- https://www.youtube.com/watch?v=UC5xf8FbdJc
- Consistent hashing:
	- https://www.youtube.com/watch?v=NLMZzElM8Z4
	- https://www.youtube.com/watch?v=4kd40gEKaLM